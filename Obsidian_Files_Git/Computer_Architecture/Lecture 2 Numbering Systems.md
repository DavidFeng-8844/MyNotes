## Kinds of data 

* Numerical Data 
* Textual Data
* Logical Data 

## Numbering System 

> A numbering system assigns meaning to the position of the numeric symbols 

## Radix Number Systems

 >For Decimal System, the choice of 10 as the base for exponentiation, called the radix, is made.

## Binary system 


>Binary is base 2 and has 2 digitals. A collection of n bits has 2npossible states.

## Bit, Bytes, and Words

- Bit- Binary Digital (0 or 1)
- Byte - 8 bits
- Word - the number of bits a processor can process==(read/write); It is 32/64 bits in most systems==
- ![[L2-1.png]]
---
## Converting 
### Binary to Decimal 

Example:
Every digit in a binary number represents a power of 2. For example if we were working with the binary number ‘00001101” we could convert it to decimal with that chart:
![[L2-2.png]]

### Decimal to Binary
Examples: 
![[L2-3.png]]

---
## Hexadecimal

>Def:
>It uses 16 different symbols, the numbers 0 through 9, and the letters ==A through F==. Each symbol represents four bits.
>

>Pros: save memory

### From base 16 to Binary 
Each hexadecimal digit translates into four binary digits, with the 4 bits
immediately to the left (or right).It may be necessary to add
one or two leading or trailing zeros to fill out a group

>Example:
>![[L2-4.png]]

--- 
---
## Octal Number 

### Octal to Binary 
>Each octal digital to a 3-bit binary, with the 3 bits
immediately to the left (or right). It may be necessary to add
one or two leading or trailing zeros to fill out a group
>![[L2-5.png]]
### Binary to Octal
>Group the binary bits into sets of 3 (because 23= 8). You may need to pad with leading zeros
>![[L2-6.png]]

---
---
## Negative Binary Numbers
>Intro:
>==Four different systems for representing negative numbers have been used== in
digital computers at one time or another in history.
1.  signed magnitude. Leftmost bit==(0 +/1 -)==.
2. ==one's complement.(Obsolete)== To negate a number, replace each 1 by a 0 and each 0 by a 1.To negate a number, replace each 1 by a 0 and each 0 by a 1. This holds for the sign bit as well.
3. ==Second's Complement== Negating a number is a two-step process. First, each 1 is replaced by a 0 and each 0 by a 1, just as in one’s complement. Second, 1 is added to the result
4. Excess 2^(m-1)  for m bits numbers For example, for 8-bit numbers, m = 8, the system is called excess 128. The numbers from −128 to +127 map onto 0 to 255, all of which are expressible as an 8-bit positive integer.

>Pros: Both signed magnitude and one’s complement have two representations for
zero: ==a plus zero, and a minus zero. This situation is undesirable==. The two’s complement
system does not have this problem because the two’s complement of plus
zero is also plus zero. 


>Cons: Different Singularity 
>The problem is that any set of numbers with as many positive as negative numbers
and only one zero has an odd number of members, whereas ==m bits allow an even
number of bit patterns.==There will always be either one bit pattern too many or one
bit pattern too few, no matter what representation is chosen. This extra bit pattern
can be used for −0 or for a large negative number, or for something else, but no
matter what it is used for it will always be a nuisance 


---
---
## Binary Arithmetic
---
### Addition 
Base-2 addition –just like Base 10!
–
add from right to left, propagating carry

![[L2-7.png]]

### Addition for 1 and 2's Complement 
>In one’s complement arithmetic, a carry generated by the addition of the leftmost bits is ==added to the rightmost bit==. This process is called an end-around carry. In two’s complement arithmetic, a carry generated by the addition of the leftmost bits is ==merely thrown==
>![[L2-9.png]]
away. Examples of binary arithmetic are shown in
---
### Binary Multiplication 
**Step 1:** Write down the multiplicand (11101)211101)2 and the multiplier (1001)21001)2 one below the other in proper positions.  
**Step 2:** Multiply the rightmost digit or the least significant bit (LSB) of the multiplier (1) with all the digits of the multiplicand (11101)211101)2.  
**Step 3:** Add a place holder of '0' or 'X' before multiplying the next higher order digit of the multiplier& with the multiplicand.  
**Step 4:** Repeat the same process for all the next higher-order digits until we reach the most significant bit (MSB) which is the left-most digit of the multiplicand with the multiplier.  
**Step 5:** The product obtained in each row is called the partial product. Finally, add all the partial products. To add all the binary numbers use the rules of binary addition.

![[L2-10.png]]


## Fractions Number point or radix point

>**Some numbers cannot be represented (exactly) in some bases (with terminating, finite representations). Exact conversion may be impossible**

### Binary Radix Point 

![[L2-11.png]]
**Integer and fractional parts must be converted separately**

### Range of Possible numbers 

R = $B^k$
where R=range, B=base, k=number of digits

---
---

## Binary Coded Decimal (BCD)

| DEC | BI        | BCD       |
| --- | --------- | --------- |
| 68  | 0100 0100 | 0110 1000 |

